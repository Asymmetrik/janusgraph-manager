{"version":3,"sources":["webpack://janusgraphmanager/webpack/universalModuleDefinition","webpack://janusgraphmanager/./src/JanusGraphManager.ts","webpack://janusgraphmanager/./src/builders/EdgeBuilder.ts","webpack://janusgraphmanager/./src/builders/EnableIndexBuilder.ts","webpack://janusgraphmanager/./src/builders/GraphIndexBuilder.ts","webpack://janusgraphmanager/./src/builders/PropertyBuilder.ts","webpack://janusgraphmanager/./src/builders/VertexBuilder.ts","webpack://janusgraphmanager/./src/builders/VertexCentricIndexBuilder.ts","webpack://janusgraphmanager/./src/builders/index.ts","webpack://janusgraphmanager/webpack/bootstrap","webpack://janusgraphmanager/webpack/startup"],"names":["root","factory","exports","module","define","amd","self","client","graphName","useConfiguredGraphFactory","state","OPEN_MGMT","this","init","submit","Promise","resolve","reject","createIndices","schema","commit","count","all","graphIndices","map","i","builder","GraphIndexBuilder","name","label","type","unique","keys","forEach","k","key","build","msg","length","vcIndices","VertexCentricIndexBuilder","direction","edgelabel","order","enableIndices","gi","EnableIndexBuilder","vci","createSchema","indices","vertices","edges","flatMap","v","properties","p","PropertyBuilder","datatype","cardinality","VertexBuilder","property","e","EdgeBuilder","message","close","JanusGraphManager","_label","_multiplicity","_properties","multiplicity","some","push","output","prop","join","_name","_graph","_type","console","warn","Error","_keys","field","_unique","mapping","concat","_key","_cardinality","_datatype","Set","_order","_edgelabel","_direction","add","size","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"mappings":"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","file":"index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"janusgraphmanager\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"janusgraphmanager\"] = factory();\n\telse\n\t\troot[\"janusgraphmanager\"] = factory();\n})(self, function() {\nreturn ","import { driver } from \"gremlin\";\nimport { GraphSchema } from \"./types/GraphSchema\";\nimport {\n    EdgeBuilder,\n    EnableIndexBuilder,\n    GraphIndexBuilder,\n    PropertyBuilder,\n    VertexBuilder,\n    VertexCentricIndexBuilder,\n} from \"./builders\";\n\ntype ManagerState = \"NEW\" | \"INITIALIZED\" | \"ERROR\" | \"CLOSED\";\n\nexport class JanusGraphManager {\n\n    private state: ManagerState = \"NEW\";\n\n    private OPEN_MGMT = `mgmt = ${this.graphName}.openManagement();0;`;\n\n    /**\n     * \n     * @param client Preconfigured gremlin client to use. Using a client with a defined session name is recommended.\n     * @param graphName Name of the graph to traverse. Default `graph`.\n     * @param useConfiguredGraphFactory Whether or not to use the ConfiguredGraphFactory for dynamic graphs. Default `false`.\n     */\n    constructor(private client: driver.Client, private graphName: string = 'graph', private useConfiguredGraphFactory: boolean = false) {\n    }\n\n    /**\n     * Opens the management system for the client session.\n     * @returns A promise with the state of the manager.\n     */\n    async init(): Promise<ManagerState> {\n        try {\n            if (this.useConfiguredGraphFactory) {\n                await this.client.submit(`${this.graphName} = ConfiguredGraphFactory.open('${this.graphName})`);\n            }\n            await this.client.submit(this.OPEN_MGMT);\n            this.state = \"INITIALIZED\";\n            return Promise.resolve(this.state);\n        } catch (err) {\n            this.state = \"ERROR\";\n            return Promise.reject(\"ERROR\");\n        }\n    }\n\n    /**\n     * Will build only the indices from a graph schema.\n     * @param schema - GraphSchema to get index definitions from.\n     * @param commit - Whether or not to commit and close the traversal. Default: `false`\n     * @returns A promise containing the number of successful traversals made.\n     */\n    async createIndices(schema: GraphSchema, commit = false): Promise<number> {\n        try {\n            let count = 0;\n            // Generate graph indices.\n            count += (\n                await Promise.all(\n                    schema.graphIndices\n                        .map((i) => {\n                            const builder = new GraphIndexBuilder(i.name);\n                            builder\n                                .label(i.label)\n                                .type(i.type)\n                                .unique(i.unique);\n                            i.keys.forEach((k) => builder.key(k));\n                            return builder.build();\n                        })\n                        .map((msg) => this.client.submit(msg))\n                )\n            ).length;\n            // Generate vc indices.\n            count += (\n                await Promise.all(\n                    schema.vcIndices\n                        .map((i) => {\n                            const builder = new VertexCentricIndexBuilder(\n                                i.name\n                            );\n                            builder\n                                .direction(i.direction)\n                                .edgelabel(i.edgelabel)\n                                .order(i.order);\n                            i.keys.forEach((k) => builder.key(k));\n                            return builder.build();\n                        })\n                        .map((msg) => this.client.submit(msg))\n                )\n            ).length;\n            if (commit) {\n                await this.commit();\n            }\n            return Promise.resolve(count);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }\n\n    /**\n     * Attempts to enable indices.\n     * @param schema - GraphSchema to enable indicies for. \n     * @param commit - Whether or not to commit and close the traversal. Default: `false`\n     * @returns A promise containing the number of successful traversals made.\n     */\n    async enableIndices(schema: GraphSchema, commit = false): Promise<number> {\n        try {\n            const gi = schema.graphIndices\n            .map((i) => {\n                const builder = new EnableIndexBuilder(i.name, schema.name);\n                return builder.build();\n            });\n            const vci = schema.vcIndices\n                .map((i) => {\n                    const builder = new EnableIndexBuilder(i.name, schema.name);\n                    return builder.type(\"VertexCentric\")\n                        .label(i.edgelabel)\n                        .build();\n                });\n            const count = [...gi, ...vci].map((msg) => this.client.submit(msg)).length;\n            if (commit) {\n                await this.commit();\n            }\n            return Promise.resolve(count);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }\n\n    /**\n     * Creates all the schema definitions.\n     * @param schema - GraphSchema to get schema definitions from.\n     * @param indices - If set `true`, will build indices as well. Default `false`.\n     * @returns A promise containing the number of successful traversals made.\n     */\n    async createSchema(schema: GraphSchema, indices = false): Promise<number> {\n        try {\n            let count = 0;\n            // Extract/Build our properties definitions.\n            count += (\n                await Promise.all(\n                    [...schema.vertices, ...schema.edges]\n                        .flatMap((v) => v.properties)\n                        .map((p) => {\n                            const builder = new PropertyBuilder(p.key);\n                            return builder\n                                .datatype(p.datatype)\n                                .cardinality(p.cardinality)\n                                .build();\n                        })\n                        .map((msg) => this.client.submit(msg))\n                )\n            ).length;\n            // Create labels and associate properties for vertices.\n            count += (\n                await Promise.all(\n                    schema.vertices\n                        .map((v) => {\n                            const builder = new VertexBuilder(v.label);\n                            v.properties.forEach((p) => builder.property(p));\n                            return builder.build();\n                        })\n                        .map((msg) => this.client.submit(msg))\n                )\n            ).length;\n            // Create labels and associate properties for edges.\n            count += (\n                await Promise.all(\n                    schema.edges\n                        .map((e) => {\n                            const builder = new EdgeBuilder(e.label);\n                            e.properties.forEach((p) => builder.property(p));\n                            return builder.build();\n                        })\n                        .map((msg) => this.client.submit(msg))\n                )\n            ).length;\n            if (indices) {\n                count += await this.createIndices(schema);\n            }\n            await this.commit();\n            return Promise.resolve(count);\n        } catch (err) {\n            return Promise.reject(err);\n        }\n    }\n\n    /**\n     * Leverages the gremlin client to commit a management message.\n     * @param message Message to send prior to the commit. Not required.\n     * @returns \n     */\n    async commit(message?: string): Promise<unknown> {\n        try {\n            const close = await this.client.submit(`${message ?? \"\"};mgmt.commit();`);\n            this.state = \"CLOSED\";\n            return close;\n        } catch (err) {\n            this.state = \"ERROR\";\n            return Promise.reject(err);\n        }\n    }\n}\n","import { Builder } from \"./Builder.interface\";\nimport { EdgeMultiplicity } from \"../types/Edge\";\nimport { Property } from \"../types/Property\";\n\nexport class EdgeBuilder implements Builder<string> {\n    private _multiplicity: EdgeMultiplicity = \"MULTI\";\n    private _properties: Property[] = [];\n\n    constructor(private _label: string) {}\n\n    multiplicity(multiplicity: EdgeMultiplicity): this {\n        this._multiplicity = multiplicity;\n        return this;\n    }\n\n    property(property: Property): this {\n        if (this._properties.some((p) => p.key === property.key)) return this;\n        this._properties.push(property);\n        return this;\n    }\n\n    build(): string {\n        let output = `if (!mgmt.containsEdgeLabel('${this._label}')) `;\n        output += `mgmt.makeEdgeLabel('${this._label}')`;\n        output +=\n            this._multiplicity != null\n                ? `.multiplicity(${this._multiplicity})`\n                : \"\";\n        output += \".make();\";\n        if (this._properties.length > 0) {\n            output += \"mgmt.addProperties(\";\n            output += `mgmt.getEdgeLabel('${this._label}'), `;\n            output += [...this._properties]\n                .map((prop) => `mgmt.getPropertyKey('${prop.key}')`)\n                .join(\", \");\n            output += \")\";\n        }\n        return output;\n    }\n}\n","import { IndexType } from '../types/GraphIndex';\nimport { Builder } from './Builder.interface';\n\n/**\n * Builds a management string that attempts to enable a specific index.\n */\nexport class EnableIndexBuilder implements Builder<string> {\n    private _type!: IndexType;\n    private _label!: string;\n\n    /**\n     * Default constructor.\n     * @param _name Index to attempt to enable.\n     * @param _graph Graph name that the index resides on. Default `graph`.\n     */\n    constructor(private _name: string, private _graph: string = 'graph') {}\n\n    type(type: IndexType): this {\n        this._type = type;\n        return this;\n    }\n\n    /**\n     * Sets the vertex label for VertexCentric indicies.\n     * @param label Label\n     * @returns The builder.\n     */\n    label(label: string): this {\n        if (this._type !== 'VertexCentric') {\n            console.warn(\n                `Label ${label} set on EnableIndex builder. This only applies for VertexCentric indices.`\n            );\n        }\n        this._label = label;\n        return this;\n    }\n\n    /**\n     * Builds the output string.\n     * @returns String that calls ENABLE_INDEX in JG.\n     * @throws An Error if an attempt is made to enable a VertexCentric index without a label.\n     */\n    build(): string {\n        let output = 'mgmt.updateIndex(';\n        if (this._type === 'VertexCentric') {\n            if (this._label == null || this._label === '')\n                throw Error(\n                    `Vertex Centric index '${this._name}' attempted to be enabled without a label definition.`\n                );\n            output += `mgmt.getRelationIndex(${this._graph}, '${this._name}', '${this._label}')`;\n        } else {\n            output += `mgmt.getGraphIndex(${this._graph}, '${this._name}')`;\n        }\n        output += `, SchemaAction.ENABLE_INDEX);`;\n        return output;\n    }\n}\n","import { Builder } from \"./Builder.interface\";\nimport { CompositeOrMixedIndexType, IndexKey, IndexType } from \"../types/GraphIndex\";\n\n/**\n * Index Builder for Composite or Mixed indices.\n * \n * For VertexCentric indicies, please use {@link VertexCentricIndexBuilder}\n */\nexport class GraphIndexBuilder implements Builder<string> {\n    private _type?: CompositeOrMixedIndexType;\n    private _keys: IndexKey[] = [];\n    private _unique?: boolean;\n    private _label?: string;\n\n    constructor(private _name: string) {}\n\n    type(type: CompositeOrMixedIndexType): this {\n        this._type = type;\n        return this;\n    }\n\n    key(key: IndexKey): this {\n        if (this._keys.some((k) => k.field === key.field)) return this;\n        this._keys.push(key);\n        return this;\n    }\n\n    unique(unique = false): this {\n        this._unique = unique;\n        return this;\n    }\n    \n    label(label?: string): this {\n        this._label = label;\n        return this;\n    }\n\n    build(): string {\n        if (this._keys.length === 0) {\n            throw Error(`Unable to generate index ${this._name} with no key definitions.`);\n        }\n        let output = `if (!mgmt.containsGraphIndex('${this._name}')) `;\n        output += `mgmt.buildIndex('${this._name}', Vertex.class)`;\n        output += [...this._keys]\n            .map(\n                (key) =>\n                    `.addKey(mgmt.getPropertyKey('${key.field}'), Mapping.${key.mapping}.getParameter())`\n            )\n            .join(\"\");\n        output += this._unique ? `.unique()` : \"\";\n        output += this._label != null ? `.indexOnly(mgmt.getVertexLabel('${this._label}'))` : \"\";\n        return output.concat(\n            this._type === \"Mixed\"\n                ? '.buildMixedIndex(\"search\");'\n                : \".buildCompositeIndex();\"\n        );\n    }\n}\n","import { Builder } from \"./Builder.interface\";\nimport { PropertyCardinality, PropertyType } from \"../types/Property\";\n\nexport class PropertyBuilder implements Builder<string> {\n    private _datatype!: PropertyType;\n    private _cardinality: PropertyCardinality = \"SINGLE\";\n\n    constructor(private _key: string) {}\n\n    cardinality(cardinality: PropertyCardinality): this {\n        this._cardinality = cardinality;\n        return this;\n    }\n\n    datatype(datatype: PropertyType): this {\n        this._datatype = datatype;\n        return this;\n    }\n\n    build(): string {\n        let output = `if (!mgmt.containsPropertyKey('${this._key}')) `;\n        output += `mgmt.makePropertyKey('${this._key}')`;\n        output +=\n            this._datatype != null ? `.dataType(${this._datatype}.class)` : \"\";\n        output +=\n            this._cardinality != null\n                ? `.cardinality(Cardinality.${this._cardinality})`\n                : \"\";\n        return output.concat(\".make();\");\n    }\n}\n","import { Builder } from './Builder.interface';\nimport { Property } from '../types/Property';\n\nexport class VertexBuilder implements Builder<string> {\n    private _properties: Property[] = [];\n\n    constructor(private _label: string) {}\n\n    property(property: Property): this {\n        if (this._properties.some((p) => p.key === property.key)) return this;\n        this._properties.push(property);\n        return this;\n    }\n\n    build(): string {\n        let output = `if (!mgmt.containsVertexLabel('${this._label}')) `;\n        output += `mgmt.makeVertexLabel('${this._label}')`;\n        output += '.make();';\n        if (this._properties.length > 0) {\n            output += 'mgmt.addProperties(';\n            output += `mgmt.getVertexLabel('${this._label}'), `;\n            output += [...this._properties]\n                .map((prop) => `mgmt.getPropertyKey('${prop.key}')`)\n                .join(', ');\n            output += ')';\n        }\n        return output;\n    }\n}\n","import { Builder } from \"./Builder.interface\";\nimport { Direction, Order } from \"../types/VertexCentricIndex\";\n\n/**\n * Index Builder for Vertex Centric indices.\n * \n * For Mixed/Composite, please use {@link IndexBuilder}\n */\nexport class VertexCentricIndexBuilder implements Builder<string> {\n    private _keys: Set<string> = new Set();\n    private _direction!: Direction;\n    private _order: Order = \"asc\";\n    private _edgelabel!: string;\n\n    constructor(private _name: string) {}\n\n    edgelabel(edgelabel: string): this {\n        this._edgelabel = edgelabel;\n        return this;\n    }\n\n    direction(direction: Direction): this {\n        this._direction = direction;\n        return this;\n    }\n\n    order(order: Order): this {\n        this._order = order;\n        return this;\n    }\n\n    key(key: string): this {\n        this._keys.add(key);\n        return this;\n    }\n\n    build(): string {\n        if (this._keys.size === 0) {\n            throw Error(`Unable to generate vc index ${this._name} with no key definitions.`);\n        }\n        if (this._direction == null) {\n            throw Error(`Unable to generate vc index ${this._name} with no directionality.`);\n        }\n        if (this._edgelabel == null || this._edgelabel === '') {\n            throw Error(`Unable to generate vc index ${this._name} with no edge label.`);\n        }\n        let output = `if (!mgmt.containsGraphIndex('${this._name}')) `;\n        output += `mgmt.buildEdgeIndex(`;\n        output += `mgmt.getEdgeLabel('${this._edgelabel}'), `;\n        output += `'${this._name}', `;\n        output += `Direction.${this._direction}, `;\n        output += `Order.${this._order}, `;\n        output += [...this._keys]\n            .map((key) => `mgmt.getPropertyKey('${key}')`)\n            .join(\", \");\n        return output.concat(\");\");\n    }\n}\n","export * from \"./EdgeBuilder\";\nexport * from \"./EnableIndexBuilder\";\nexport * from \"./GraphIndexBuilder\";\nexport * from \"./PropertyBuilder\";\nexport * from \"./VertexBuilder\";\nexport * from \"./VertexCentricIndexBuilder\";","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(352);\n"],"sourceRoot":""}